<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Documentation Page</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    
    <nav id="navbar">
        <header>Python: Data Structures</header>
        <ul>
            <li><a class="nav-link" href="#More_on_Lists">1. More on Lists</a></li>
            <li><a class="nav-link" href="#The_del_statement">2. The del statement</a></li>
            <li><a class="nav-link" href="#Tuples_and_Sequences">3. Tuples and Sequences</a></li>
            <li><a class="nav-link" href="#Sets">4. Sets</a></li>
            <li><a class="nav-link" href="#Dictionaries">5. Dictionaries</a></li>
            <li><a class="nav-link" href="#Looping_Techniques">6. Looping Techniques</a></li>
            <li><a class="nav-link" href="#More_on_Conditions">7. More on Conditions</a></li>
            <li><a class="nav-link" href="#Comparing_Sequences_and_Other_Types">8. Comparing Sequences and Other Types</a></li>
            <li><a class="nav-link" href="#Reference">Reference</a></li>
        </ul>
    </nav>

    <main id="main-doc">

        <section class="main-section" id="More_on_Lists">
            <header>1. More on Lists</header>
            <article>
                <p>
                    The list data type has some more methods. 
                    Here are all of the methods of list objects
                </p>
                <dl>
                    <dt>
                        <code class="nbk-code class-name">list.</code>
                        <code class="nbk-code class-method">append</code>
                        <code class="nbk-code class-arg">(x)</code>
                    </dt>
                    <dd>
                        <p>
                            Add an item to the end of the list. Equivalent to 
                            <code class="desc-code">a[len(a):] = [x]</code>
                            .
                        </p>
                    </dd>
                </dl>
                <dl>
                    <dt>
                        <code class="nbk-code class-name">list.</code>
                        <code class="nbk-code class-method">extend</code>
                        <code class="nbk-code class-arg">(iterable)</code>
                    </dt>
                    <dd>
                        <p>
                            Extend the list by appending all the items from the iterable. 
                            Equivalent to 
                            <code class="desc-code">a[len(a):] = iterable</code>
                            .
                        </p>
                    </dd>
                </dl>
                <dl>
                    <dt>
                        <code class="nbk-code class-name">list.</code>
                        <code class="nbk-code class-method">insert</code>
                        <code class="nbk-code class-arg">(i, x)</code>
                    </dt>
                    <dd>
                        <p>
                            Insert an item at a given position. The first argument is 
                            the index of the element before which to insert, so 
                            <code class="desc-code">a.insert(0, x)</code>
                            inserts at the front of the list, and
                            <code class="desc-code">a.insert(len(a), x)</code> 
                            is equivalent to 
                            <code class="desc-code">a.append(x)</code>
                            .
                        </p>
                    </dd>
                </dl>
                <dl>
                    <dt>
                        <code class="nbk-code class-name">list.</code>
                        <code class="nbk-code class-method">remove</code>
                        <code class="nbk-code class-arg">(x)</code>
                    </dt>
                    <dd>
                        <p>
                            Remove the first item from the list whose value is equal to x. 
                            It raises a ValueError if there is no such item.                            
                        </p>
                    </dd>
                </dl>
                <dl>
                    <dt>
                        <code class="nbk-code class-name">list.</code>
                        <code class="nbk-code class-method">pop</code>
                        <code class="nbk-code class-arg">([i])</code>
                    </dt>
                    <dd>
                        <p>
                            Remove the item at the given position in the list, 
                            and return it. If no index is specified, a.pop() 
                            removes and returns the last item in the list. 
                            (The square brackets around the i in the method 
                            signature denote that the parameter is optional, 
                            not that you should type square brackets at that position. 
                            You will see this notation frequently in the Python Library Reference.)                            
                        </p>
                    </dd>
                </dl>
                <dl>
                    <dt>
                        <code class="nbk-code class-name">list.</code>
                        <code class="nbk-code class-method">clear</code>
                        <code class="nbk-code class-arg">()</code>
                    </dt>
                    <dd>
                        <p>
                            Remove all items from the list. Equivalent to 
                            <code class="desc-code">del a[:]</code>
                            .
                        </p>
                    </dd>
                </dl>
                <dl>
                    <dt>
                        <code class="nbk-code class-name">list.</code>
                        <code class="nbk-code class-method">index</code>
                        <code class="nbk-code class-arg">(x[, start[, end]])</code>
                    </dt>
                    <dd>
                        <p>
                            Return zero-based index in the list of the first item 
                            whose value is equal to x. Raises a ValueError 
                            if there is no such item. 
                        </p>
                        <p>
                            The optional arguments start and end are interpreted 
                            as in the slice notation and are used to limit the search 
                            to a particular subsequence of the list. The returned index is 
                            computed relative to the beginning of the full sequence rather 
                            than the start argument.
                        </p>
                    </dd>
                </dl>
                <dl>
                    <dt>
                        <code class="nbk-code class-name">list.</code>
                        <code class="nbk-code class-method">count</code>
                        <code class="nbk-code class-arg">(x)</code>
                    </dt>
                    <dd>
                        <p>
                            Return the number of times x appears in the list. 
                        </p>
                    </dd>
                </dl>
                <dl>
                    <dt>
                        <code class="nbk-code class-name">list.</code>
                        <code class="nbk-code class-method">sort</code>
                        <code class="nbk-code class-arg">(*, key=None, reverse=False)</code>
                    </dt>
                    <dd>
                        <p>
                            Sort the items of the list in place 
                            (the arguments can be used for sort customization, 
                            see sorted() for their explanation).
                        </p>
                    </dd>
                </dl>
                <dl>
                    <dt>
                        <code class="nbk-code class-name">list.</code>
                        <code class="nbk-code class-method">reverse</code>
                        <code class="nbk-code class-arg">()</code>
                    </dt>
                    <dd>
                        <p>
                            Reverse the elements of the list in place.
                        </p>
                    </dd>
                </dl>
                <dl>
                    <dt>
                        <code class="nbk-code class-name">list.</code>
                        <code class="nbk-code class-method">copy</code>
                        <code class="nbk-code class-arg">()</code>
                    </dt>
                    <dd>
                        <p>
                            Return a shallow copy of the list. Equivalent to 
                            <code class="desc-code">del a[:]</code>
                            .
                        </p>
                    </dd>
                </dl>
                <p>An example that uses most of the list methods:</p>
<pre class="ex-code">
>>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
>>> fruits.count('apple')
2
>>> fruits.count('tangerine')
0
>>> fruits.index('banana')
3
>>> fruits.index('banana', 4)  # Find next banana starting a position 4
6
>>> fruits.reverse()
>>> fruits
['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']
>>> fruits.append('grape')
>>> fruits
['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']
>>> fruits.sort()
>>> fruits
['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']
>>> fruits.pop()
'pear'
</pre>
                <p>
                    You might have noticed that methods like insert, 
                    remove or sort that only modify the list have no return value printed – 
                    they return the default None. 1 This is a design principle for all mutable 
                    data structures in Python.
                </p>
                <p>
                    Another thing you might notice is that not all data can be sorted 
                    or compared. For instance, [None, 'hello', 10] doesn’t sort because 
                    integers can’t be compared to strings and None can’t be compared 
                    to other types. Also, there are some types that don’t have a defined 
                    ordering relation. For example, 3+4j < 5+7j isn’t a valid comparison.
                </p>
                <h2>
                    1.1. Using Lists as Stacks
                </h2>
                <p>
                    The list methods make it very easy to use a list as a stack, 
                    where the last element added is the first element retrieved 
                    (“last-in, first-out”). To add an item to the top of the stack, 
                    use append(). To retrieve an item from the top of the stack, 
                    use pop() without an explicit index. For example:
                </p>
<pre class="ex-code">
>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack.pop()
5
>>> stack
[3, 4]
</pre>
                <h2>
                    1.2. Using Lists as Queues
                </h2>
                <p>
                    It is also possible to use a list as a queue, 
                    where the first element added is the first element 
                    retrieved (“first-in, first-out”); however, lists are not efficient 
                    for this purpose. While appends and pops from the end of list are fast, 
                    doing inserts or pops from the beginning of a list is slow 
                    (because all of the other elements have to be shifted by one).
                </p>
                <p>
                    To implement a queue, use collections.deque which was designed 
                    to have fast appends and pops from both ends. For example:
                </p>
<pre class="ex-code">
>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry")           # Terry arrives
>>> queue.append("Graham")          # Graham arrives
>>> queue.popleft()                 # The first to arrive now leaves
'Eric'
>>> queue.popleft()                 # The second to arrive now leaves
'John'
>>> queue                           # Remaining queue in order of arrival
deque(['Michael', 'Terry', 'Graham'])
</pre>
                <h2>
                    1.3. List Comprehensions
                </h2>
                <p>
                    List comprehensions provide a concise way to create lists. 
                    Common applications are to make new lists where each element is 
                    the result of some operations applied to each member of another 
                    sequence or iterable, or to create a subsequence of those elements 
                    that satisfy a certain condition.
                </p>
                <p>
                    For example, assume we want to create a list of squares, like:
                </p>
<pre class="ex-code">
>>> squares = []
>>> for x in range(10):
...     squares.append(x**2)
...
>>> squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</pre>
                <p>
                    Note that this creates (or overwrites) a variable named x 
                    that still exists after the loop completes. 
                    We can calculate the list of squares without any side effects using:
                </p>
<pre class="ex-code">
squares = list(map(lambda x: x**2, range(10)))
</pre>
                <p>
                    or, equivalently:
                </p>
<pre class="ex-code">
squares = [x**2 for x in range(10)]
</pre>
                <p>
                    which is more concise and readable.
                </p>
                <p>
                    A list comprehension consists of brackets containing an expression 
                    followed by a for clause, then zero or more for or if clauses. 
                    The result will be a new list resulting from evaluating the expression in 
                    the context of the for and if clauses which follow it. For example, 
                    this listcomp combines the elements of two lists if they are not equal:
                </p>
<pre class="ex-code">
>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
</pre>
                <p>
                    and it’s equivalent to:
                </p>
<pre class="ex-code">
>>> combs = []
>>> for x in [1,2,3]:
...     for y in [3,1,4]:
...         if x != y:
...             combs.append((x, y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
</pre>
                <p>
                    Note how the order of the for and if statements is 
                    the same in both these snippets.
                </p>
                <p>
                    If the expression is a tuple (e.g. the (x, y) in 
                    the previous example), it must be parenthesized.
                </p>
<pre class="ex-code">
>>> vec = [-4, -2, 0, 2, 4]
>>> # create a new list with the values doubled
>>> [x*2 for x in vec]
[-8, -4, 0, 4, 8]
>>> # filter the list to exclude negative numbers
>>> [x for x in vec if x >= 0]
[0, 2, 4]
>>> # apply a function to all the elements
>>> [abs(x) for x in vec]
[4, 2, 0, 2, 4]
>>> # call a method on each element
>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
>>> [weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']
>>> # create a list of 2-tuples like (number, square)
>>> [(x, x**2) for x in range(6)]
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
>>> # the tuple must be parenthesized, otherwise an error is raised
>>> [x, x**2 for x in range(6)]
    File "<stdin>", line 1, in <module>
    [x, x**2 for x in range(6)]
                ^
SyntaxError: invalid syntax
>>> # flatten a list using a listcomp with two 'for'
>>> vec = [[1,2,3], [4,5,6], [7,8,9]]
>>> [num for elem in vec for num in elem]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>
                <p>
                    List comprehensions can contain complex expressions and nested functions:
                </p>
<pre class="ex-code">
>>> from math import pi
>>> [str(round(pi, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
</pre>                
                <h2>
                    1.4. Nested List Comprehensions
                </h2>
                <p>
                    The initial expression in a list comprehension can be any 
                    arbitrary expression, including another list comprehension.
                </p>
                <p>
                    Consider the following example of a 3x4 matrix implemented 
                    as a list of 3 lists of length 4:
                </p>
<pre class="ex-code">
>>> matrix = [
...     [1, 2, 3, 4],
...     [5, 6, 7, 8],
...     [9, 10, 11, 12],
... ]
</pre>
                <p>
                    The following list comprehension will transpose rows and columns:
                </p>
<pre class="ex-code">
>>> [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</pre>
                <p>
                    As we saw in the previous section, the nested listcomp 
                    is evaluated in the context of the for that follows it, 
                    so this example is equivalent to:
                </p>
<pre class="ex-code">
>>> transposed = []
>>> for i in range(4):
...     transposed.append([row[i] for row in matrix])
...
>>> transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</pre>
                <p>
                    which, in turn, is the same as:
                </p>
<pre class="ex-code">
>>> transposed = []
>>> for i in range(4):
...     # the following 3 lines implement the nested listcomp
...     transposed_row = []
...     for row in matrix:
...         transposed_row.append(row[i])
...     transposed.append(transposed_row)
...
>>> transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</pre>
                <p>
                    In the real world, you should prefer built-in functions 
                    to complex flow statements. The zip() function would do 
                    a great job for this use case:
                </p>
<pre class="ex-code">
>>> list(zip(*matrix))
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
</pre>
                <p>
                    See Unpacking Argument Lists for details on the asterisk in this line.
                </p>
            </article>
        </section>

        <section class="main-section" id="The_del_statement">
            <header>2. The del statement</header>
            <article>
                <p>
                    There is a way to remove an item from a list given 
                    its index instead of its value: the 
                    del <code class="desc-code">del</code> 
                    statement. This differs from the 
                    <code class="desc-code">pop()</code> 
                    method which returns a value. The 
                    <code class="desc-code">del</code> 
                    statement can also be used to remove slices from 
                    a list or clear the entire list (which we did earlier 
                    by assignment of an empty list to the slice). For example:
                </p>
<pre class="ex-code">
>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
>>> del a[0]
>>> a
[1, 66.25, 333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
>>> a
[]
</pre>
                <p>
                    del can also be used to delete entire variables:
                </p>
<pre class="ex-code">
>>> del a
</pre>
                <p>
                    Referencing the name a hereafter is an error 
                    (at least until another value is assigned to it). 
                    We’ll find other uses for del later.
                </p>
            </article>
        </section>

        <section class="main-section" id="Tuples_and_Sequences">
            <header>3. Tuples and Sequences</header>
            <article>
                <p>
                    We saw that lists and strings have many common properties, 
                    such as indexing and slicing operations. They are two examples 
                    of sequence data types (see Sequence Types — list, tuple, range). 
                    Since Python is an evolving language, other sequence data types 
                    may be added. There is also another standard sequence data type: 
                    the tuple.
                </p>
                <p>
                    A tuple consists of a number of values separated 
                    by commas, for instance:
                </p>
<pre class="ex-code">
>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
>>> # Tuples may be nested:
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
>>> # Tuples are immutable:
... t[0] = 88888
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> # but they can contain mutable objects:
... v = ([1, 2, 3], [3, 2, 1])
>>> v
([1, 2, 3], [3, 2, 1])
</pre>
                <p>
                    As you see, on output tuples are always enclosed in parentheses, 
                    so that nested tuples are interpreted correctly; 
                    they may be input with or without surrounding parentheses, 
                    although often parentheses are necessary anyway 
                    (if the tuple is part of a larger expression). It is not possible 
                    to assign to the individual items of a tuple, however it is possible 
                    to create tuples which contain mutable objects, such as lists.
                </p>
                <p>
                    Though tuples may seem similar to lists, they are often 
                    used in different situations and for different purposes. 
                    Tuples are immutable, and usually contain a heterogeneous 
                    sequence of elements that are accessed via unpacking 
                    (see later in this section) or indexing (or even by attribute 
                    in the case of namedtuples). Lists are mutable, 
                    and their elements are usually homogeneous and are accessed 
                    by iterating over the list.
                </p>
                <p>
                    A special problem is the construction of tuples 
                    containing 0 or 1 items: the syntax has some extra quirks 
                    to accommodate these. Empty tuples are constructed 
                    by an empty pair of parentheses; a tuple with one item is constructed 
                    by following a value with a comma (it is not sufficient 
                    to enclose a single value in parentheses). Ugly, but effective. 
                    For example:
                </p>
<pre class="ex-code">
>>> empty = ()
>>> singleton = 'hello',    # <-- note trailing comma
>>> len(empty)
0
>>> len(singleton)
1
>>> singleton
('hello',)
</pre>
                <p>
                    The statement 
                    <code class="desc-code">t = 12345, 54321, 'hello!'</code>
                    is an example of tuple packing: the values 
                    <code class="desc-code">12345</code>
                    ,  
                    <code class="desc-code">54321</code> 
                    and 
                    <code class="desc-code">'hello!'</code> 
                    are packed together in a tuple. The reverse operation is also possible:
                </p>
<pre class="ex-code">
>>> x, y, z = t
</pre>
                <p>
                    This is called, appropriately enough, sequence unpacking 
                    and works for any sequence on the right-hand side. 
                    Sequence unpacking requires that there are as many variables 
                    on the left side of the equals sign as there are elements 
                    in the sequence. Note that multiple assignment is really just 
                    a combination of tuple packing and sequence unpacking.
                </p>
            </article>
        </section>

        <section class="main-section" id="Sets">
            <header>4. Sets</header>
            <article>
                <p>
                    Python also includes a data type for sets. 
                    A set is an unordered collection with no duplicate elements. 
                    Basic uses include membership testing and eliminating duplicate entries. 
                    Set objects also support mathematical operations like union, intersection, 
                    difference, and symmetric difference.
                </p>
                <p>
                    Curly braces or the set() function can be used to create sets. 
                    Note: to create an empty set you have to use 
                    <code class="desc-code">set()</code> 
                    , not 
                    <code class="desc-code">{};</code> 
                    the latter creates an empty dictionary, a data structure 
                    that we discuss in the next section.                    
                </p>
                <p>
                    Here is a brief demonstration:
                </p>
<pre class="ex-code">
>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)                      # show that duplicates have been removed
{'orange', 'banana', 'pear', 'apple'}
>>> 'orange' in basket                 # fast membership testing
True
>>> 'crabgrass' in basket
False

>>> # Demonstrate set operations on unique letters from two words
...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # unique letters in a
{'a', 'r', 'b', 'c', 'd'}
>>> a - b                              # letters in a but not in b
{'r', 'd', 'b'}
>>> a | b                              # letters in a or b or both
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
>>> a & b                              # letters in both a and b
{'a', 'c'}
>>> a ^ b                              # letters in a or b but not both
{'r', 'd', 'b', 'm', 'z', 'l'}
</pre>
                <p>
                    Similarly to list comprehensions, set comprehensions are also supported:
                </p>
<pre class="ex-code">
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}
</pre>
            </article>
        </section>

        <section class="main-section" id="Dictionaries">
            <header>5. Dictionaries</header>
            <article>
                <p>
                    Another useful data type built into Python is the dictionary 
                    (see Mapping Types — dict). Dictionaries are sometimes found 
                    in other languages as “associative memories” or “associative arrays”. 
                    Unlike sequences, which are indexed by a range of numbers, dictionaries 
                    are indexed by keys, which can be any immutable type; strings 
                    and numbers can always be keys. Tuples can be used as keys 
                    if they contain only strings, numbers, or tuples; if a tuple contains 
                    any mutable object either directly or indirectly, it cannot be used as a key. 
                    You can’t use lists as keys, since lists can be modified in place using 
                    index assignments, slice assignments, or methods like  
                    <code class="desc-code">append()</code> 
                    and  
                    <code class="desc-code">extend()</code> 
                    .
                </p>
                <p>
                    It is best to think of a dictionary as a set of key: 
                    value pairs, with the requirement that the keys are unique 
                    (within one dictionary). A pair of braces creates an empty 
                    dictionary: 
                    <code class="desc-code">{}</code>. 
                    Placing a comma-separated list of key:value pairs within 
                    the braces adds initial key:value pairs to the dictionary; 
                    this is also the way dictionaries are written on output.
                </p>
                <p>
                    The main operations on a dictionary are storing a value 
                    with some key and extracting the value given the key. 
                    It is also possible to delete a key:value pair with 
                    <code class="desc-code">del</code>. 
                    If you store using a key that is already in use, 
                    the old value associated with that key is forgotten. 
                    It is an error to extract a value using a non-existent key.
                </p>
                <p>
                    Performing 
                    <code class="desc-code">del</code> 
                    on a dictionary returns a list of all the keys 
                    used in the dictionary, in insertion order 
                    (if you want it sorted, just use 
                    <code class="desc-code">sorted(d)</code> 
                    instead). To check whether a single key is in the dictionary, use the 
                    <code class="desc-code">in</code> 
                    keyword.
                </p>
                <p>
                    Here is a small example using a dictionary:
                </p>
<pre class="ex-code">
>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127
>>> tel
{'jack': 4098, 'sape': 4139, 'guido': 4127}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'jack': 4098, 'guido': 4127, 'irv': 4127}
>>> list(tel)
['jack', 'guido', 'irv']
>>> sorted(tel)
['guido', 'irv', 'jack']
>>> 'guido' in tel
True
>>> 'jack' not in tel
False
</pre>
                <p>
                    The 
                    <code class="desc-code">dict()</code> 
                    constructor builds dictionaries directly from sequences of key-value pairs:
                </p>
<pre class="ex-code">
>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'guido': 4127, 'jack': 4098}
</pre>
                <p>
                    In addition, dict comprehensions can be used 
                    to create dictionaries from arbitrary key and value expressions:
                </p>
<pre class="ex-code">
>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
</pre>
                <p>
                    When the keys are simple strings, it is sometimes easier 
                    to specify pairs using keyword arguments:
                </p>
<pre class="ex-code">
>>> dict(sape=4139, guido=4127, jack=4098)
{'sape': 4139, 'guido': 4127, 'jack': 4098}
</pre>
            </article>
        </section>

        <section class="main-section" id="Looping_Techniques">
            <header>6. Looping Techniques</header>
            <article>
                <p>
                    When looping through dictionaries, 
                    the key and corresponding value can be retrieved at 
                    the same time using the 
                    <code class="desc-code">items()</code> 
                    method.
                </p>
<pre class="ex-code">
>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k, v in knights.items():
...     print(k, v)
...
gallahad the pure
robin the brave
</pre>
                <p>
                    When looping through a sequence, the position index 
                    and corresponding value can be retrieved 
                    at the same time using the 
                    <code class="desc-code">enumerate()</code> 
                    function.
                </p>
<pre class="ex-code">
>>> for i, v in enumerate(['tic', 'tac', 'toe']):
...     print(i, v)
...
0 tic
1 tac
2 toe
</pre>
                <p>
                    To loop over two or more sequences at the same time, 
                    the entries can be paired with the 
                    <code class="desc-code">zip()</code> 
                    function.
                </p>
<pre class="ex-code">
>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
...     print('What is your {0}?  It is {1}.'.format(q, a))
...
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
</pre>
                <p>
                    To loop over a sequence in reverse, first specify 
                    the sequence in a forward direction and then call the 
                    <code class="desc-code">reversed()</code> 
                    function.
                </p>
<pre class="ex-code">
>>> for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1
</pre>
                <p>
                    To loop over a sequence in sorted order, use the 
                    <code class="desc-code">sorted()</code> 
                    function which returns a new sorted list 
                    while leaving the source unaltered.
                </p>
<pre class="ex-code">
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for i in sorted(basket):
...     print(i)
...
apple
apple
banana
orange
orange
pear
</pre>
                <p>
                    Using 
                    <code class="desc-code">set()</code> 
                    on a sequence eliminates duplicate elements. The use of  
                    <code class="desc-code">sorted()</code> 
                    in combination with  
                    <code class="desc-code">set()</code> 
                    over a sequence is an idiomatic way to loop over 
                    unique elements of the sequence in sorted order.
                </p>
<pre class="ex-code">
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
...     print(f)
...
apple
banana
orange
pear
</pre>
                <p>
                    It is sometimes tempting to change a list 
                    while you are looping over it; however, 
                    it is often simpler and safer to create 
                    a new list instead.
                </p>
<pre class="ex-code">
>>> import math
>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]
>>> filtered_data = []
>>> for value in raw_data:
...     if not math.isnan(value):
...         filtered_data.append(value)
...
>>> filtered_data
[56.2, 51.7, 55.3, 52.5, 47.8]
</pre>
            </article>
        </section>

        <section class="main-section" id="More_on_Conditions">
            <header>7. More on Conditions</header>
            <article>
                <p>
                    The conditions used in 
                    <code class="desc-code">while</code> 
                    and   
                    <code class="desc-code">if</code> 
                    statements can contain any operators, not just comparisons.
                </p>
                <p>
                    The comparison operators 
                    <code class="desc-code">in</code> 
                    and 
                    <code class="desc-code">not in</code> 
                    are membership tests that determine whether 
                    a value is in (or not in) a container. The operators 
                    <code class="desc-code">is</code> 
                    and 
                    <code class="desc-code">not is</code>
                    compare whether two objects are really the same object. 
                    All comparison operators have the same priority, 
                    which is lower than that of all numerical operators.
                </p>
                <p>
                    Comparisons can be chained. For example, 
                    <code class="desc-code">a < b == c</code> 
                    tests whether
                    <code class="desc-code">a</code> 
                    is less than 
                    <code class="desc-code">b</code> 
                    and moreover 
                    <code class="desc-code">b</code> 
                    equals
                    <code class="desc-code">c</code> 
                    .
                </p>
                <p>
                    Comparisons may be combined using the Boolean operators 
                    <code class="desc-code">and</code> 
                    and 
                    <code class="desc-code">or</code> 
                    , and the outcome of a comparison 
                    (or of any other Boolean expression) 
                    may be negated with not. These have lower priorities 
                    than comparison operators; between them,  
                    <code class="desc-code">not</code> 
                    has the highest priority and 
                    <code class="desc-code">or</code> 
                    the lowest, so that 
                    <code class="desc-code">A and not B or C</code> 
                    is equivalent to 
                    <code class="desc-code">(A and (not B)) or C</code> 
                    . As always, parentheses can be used to express the desired composition.
                </p>
                <p>
                    The Boolean operators 
                    <code class="desc-code">and</code> 
                    and 
                    <code class="desc-code">or</code> 
                    are so-called short-circuit operators: their arguments are evaluated 
                    from left to right, and evaluation stops as soon as 
                    the outcome is determined. For example, if 
                    <code class="desc-code">A</code> 
                    and 
                    <code class="desc-code">B</code> 
                    are true but 
                    <code class="desc-code">C</code> 
                    is false, 
                    <code class="desc-code">A and B and C</code>
                    does not evaluate the expression 
                    <code class="desc-code">C</code>
                    . When used as a general value and not as a Boolean, 
                    the return value of a short-circuit operator is 
                    the last evaluated argument.
                </p>
                <p>
                    It is possible to assign the result of a comparison 
                    or other Boolean expression to a variable. For example,
                </p>
<pre class="ex-code">
>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>> non_null
'Trondheim'
</pre>
                <p>
                    Note that in Python, unlike C, assignment inside expressions 
                    must be done explicitly with the walrus operator 
                    <code class="desc-code">:=</code> 
                    . This avoids a common class of problems encountered in C programs: typing 
                    <code class="desc-code">=</code>
                    in an expression when 
                    <code class="desc-code">==</code>
                    was intended.
                </p>
            </article>
        </section>

        <section class="main-section" id="Comparing_Sequences_and_Other_Types">
            <header>8. Comparing Sequences and Other Types</header>
            <article>
                <p>
                    Sequence objects typically may be compared to other objects 
                    with the same sequence type. The comparison uses lexicographical 
                    ordering: first the first two items are compared, 
                    and if they differ this determines the outcome of the comparison; 
                    if they are equal, the next two items are compared, and so on, 
                    until either sequence is exhausted. If two items to be compared are 
                    themselves sequences of the same type, the lexicographical 
                    comparison is carried out recursively. If all items of 
                    two sequences compare equal, the sequences are considered equal. 
                    If one sequence is an initial sub-sequence of the other, 
                    the shorter sequence is the smaller (lesser) one. 
                    Lexicographical ordering for strings uses the Unicode code 
                    point number to order individual characters. 
                    Some examples of comparisons between sequences of the same type:
                </p>
<pre class="ex-code">
(1, 2, 3)              < (1, 2, 4)
[1, 2, 3]              < [1, 2, 4]
'ABC' < 'C' < 'Pascal' < 'Python'
(1, 2, 3, 4)           < (1, 2, 4)
(1, 2)                 < (1, 2, -1)
(1, 2, 3)             == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)
</pre>
                <p>
                    Note that comparing objects of different types with 
                    <code class="desc-code"><</code> 
                    or 
                    <code class="desc-code">></code>
                    is legal provided that the objects have appropriate comparison methods. 
                    For example, mixed numeric types are compared according 
                    to their numeric value, so 0 equals 0.0, etc. Otherwise, 
                    rather than providing an arbitrary ordering, 
                    the interpreter will raise a 
                    <code class="desc-code">TypeError</code>
                    exception.
                </p>
            </article>
        </section>

        <section class="main-section" id="Reference">
            <header>Reference</header>
            <article>
                <ul>
                    <li>
                        All the documentation in this page is taken from
                        <a
                            href="https://docs.python.org/3.10/tutorial/datastructures.html#comparing-sequences-and-other-types"
                            target="_blank"
                            >
                            python.org
                        </a>
                    </li>
                </ul>
            </article>
        </section>

    </main>


</body>
</html>